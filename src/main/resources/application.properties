spring.application.name=simpleapi
# PostgreSQL Connection Properties
spring.datasource.url=jdbc:postgresql://localhost:5432/simpleapi
spring.datasource.username=postgres
spring.datasource.password=postgres
spring.datasource.driver-class-name=org.postgresql.Driver
# JPA/Hibernate Properties
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
# /api-docs endpoint custom path
springdoc.api-docs.path=/api-docs
springdoc.api-docs.enabled=true
# IBM MQ Connection Properties
# JMS configuration
spring.jms.listener.auto-startup=true
# IBM MQ configuration
ibm.mq.queueManager=QM1
ibm.mq.channel=DEV.APP.SVRCONN
ibm.mq.connName=localhost(1414)
ibm.mq.user=admin
ibm.mq.password=admin123
ibm.mq.queue.name.request=REQUEST
ibm.mq.queue.name.response=RESPONSE
ibm.mq.useIBMCipherMappings=false
ibm.mq.transportType=CLIENT
# Connection pool settings
ibm.mq.pool.enabled=true
ibm.mq.pool.maxConnections=10
# Debugging
ibm.mq.clientDebug=true
logging.level.com.ibm.mq=DEBUG
server.max-http-request-header-size=10MB


# =====================================================
# CONFIGURACIÓN DE CIRCUIT BREAKER PARA AUTENTICACIÓN
# =====================================================

# Porcentaje de llamadas fallidas que activará la apertura del circuito.
# Valor: 40% (más sensible que el predeterminado de 50%)
# Impacto: El circuito se abrirá más rápidamente ante fallos, lo que protege al sistema
#          del servicio de autenticación cuando comienza a fallar.
# Cuándo ajustar: Reducir este valor si el servicio de auth es crítico y quieres fallar
#                 aún más rápido. Aumentarlo si hay falsos positivos.
resilience4j.circuitbreaker.instances.authService.failureRateThreshold=40

# Tiempo (en ms) que el circuito permanecerá en estado ABIERTO antes de pasar a SEMI-ABIERTO.
# Valor: 15000ms (15 segundos)
# Impacto: Durante 15 segundos después de que el circuito se abra, todas las llamadas
#          fallarán rápidamente sin intentar contactar al servicio de autenticación.
# Cuándo ajustar: Reducir si necesitas recuperación más rápida, aumentar si el servicio
#                 de auth suele necesitar más tiempo para recuperarse de fallos.
resilience4j.circuitbreaker.instances.authService.waitDurationInOpenState=15000

# Tamaño de la ventana deslizante para evaluar el estado del servicio.
# Valor: 8 llamadas
# Impacto: El sistema utilizará las últimas 8 llamadas para decidir si debe
#          abrir el circuito. Un valor más pequeño hace que el sistema reaccione
#          más rápidamente a los cambios en la disponibilidad del servicio.
# Cuándo ajustar: Reducir para detectar fallos más rápido (pero riesgo de falsos positivos).
#                 Aumentar para tener evaluaciones más estables (pero respuesta más lenta a fallos).
resilience4j.circuitbreaker.instances.authService.slidingWindowSize=8

# =====================================================
# CONFIGURACIÓN DE RETRY PARA AUTENTICACIÓN
# =====================================================

# Número máximo de intentos (incluido el intento inicial).
# Valor: 2 (1 intento inicial + 1 reintento)
# Impacto: El sistema solo realizará un reintento adicional cuando falle la
#          autenticación. Esta configuración conservadora evita saturar el
#          servicio de autenticación con múltiples reintentos.
# Cuándo ajustar: Aumentar solo si los fallos transitorios son comunes y breves.
#                 No recomendado aumentar para autenticación para evitar bloqueos
#                 de cuenta o sobrecarga del servidor de auth.
resilience4j.retry.instances.authService.maxAttempts=2

# =====================================================
# CONFIGURACIÓN DE TIMELIMITER PARA AUTENTICACIÓN
# =====================================================

# Duración máxima permitida para completar la operación.
# Valor: 3s (3 segundos)
# Impacto: Si el servicio de autenticación no responde en 3 segundos, la
#          operación fallará con un TimeoutException. Esto previene bloqueos
#          de hilos y evita esperas largas en cascada.
# Cuándo ajustar: Reducir si la autenticación normalmente es más rápida y deseas
#                 fallar antes. Aumentar si el servicio de auth regularmente
#                 necesita más tiempo (no recomendado excepto en casos específicos).
resilience4j.timelimiter.instances.authService.timeoutDuration=3s

# =====================================================
# CONFIGURACIÓN DE CIRCUIT BREAKER PARA SERVICIO DE NEGOCIO
# =====================================================

# Porcentaje de llamadas fallidas que activará la apertura del circuito.
# Valor: 50% (valor estándar de Resilience4j)
# Impacto: El circuito permanecerá cerrado hasta que la mitad de las llamadas fallen,
#          proporcionando un equilibrio entre disponibilidad y protección.
# Cuándo ajustar: Reducir para servicios que deben fallar más rápido o aumentar
#                 (hasta 70-80%) para servicios que deben mantenerse disponibles
#                 incluso con tasas de fallo significativas.
# Comparación: Más tolerante que el servicio de autenticación (40%), permitiendo
#              que el servicio de negocio siga operando bajo mayor estrés.
resilience4j.circuitbreaker.instances.businessService.failureRateThreshold=50

# Tiempo (en ms) que el circuito permanecerá en estado ABIERTO antes de pasar a SEMI-ABIERTO.
# Valor: 20000ms (20 segundos)
# Impacto: Durante estos 20 segundos, todas las llamadas fallarán rápidamente sin
#          intentar contactar al servicio. Este período permite que el servicio
#          se recupere antes de recibir nuevo tráfico.
# Cuándo ajustar: Aumentar este valor para servicios que necesitan más tiempo para
#                 recuperarse tras una sobrecarga. Reducir para servicios con
#                 alta volatilidad que pueden recuperarse rápidamente.
# Comparación: Más largo que el servicio de autenticación (15s), proporcionando
#              más tiempo de recuperación para operaciones de negocio complejas.
resilience4j.circuitbreaker.instances.businessService.waitDurationInOpenState=20000

# =====================================================
# CONFIGURACIÓN DE RETRY PARA SERVICIO DE NEGOCIO
# =====================================================

# Número máximo de intentos (incluido el intento inicial).
# Valor: 3 (1 intento inicial + 2 reintentos)
# Impacto: El sistema realizará hasta 2 reintentos cuando fallen las operaciones
#          de negocio. Esta configuración más agresiva maximiza las posibilidades
#          de completar operaciones críticas de negocio.
# Cuándo ajustar: Aumentar para operaciones de solo lectura o idempotentes donde
#                 los reintentos no generan efectos secundarios. Reducir para
#                 operaciones con alta carga computacional o que consumen muchos recursos.
# Comparación: Mayor que el servicio de autenticación (2), reflejando la mayor
#              importancia de completar operaciones de negocio cuando sea posible.
resilience4j.retry.instances.businessService.maxAttempts=3

# =====================================================
# CONFIGURACIÓN DE TIMELIMITER PARA SERVICIO DE NEGOCIO
# =====================================================

# Duración máxima permitida para completar la operación.
# Valor: 8s (8 segundos)
# Impacto: Las operaciones de negocio tienen hasta 8 segundos para completarse
#          antes de que se genere un TimeoutException. Esto reconoce que las
#          operaciones de negocio suelen ser más complejas y pueden requerir
#          más tiempo que las simples verificaciones de autenticación.
# Cuándo ajustar: Aumentar para operaciones que incluyen múltiples llamadas
#                 downstream o procesamientos pesados. Reducir para mejorar
#                 la experiencia del usuario en operaciones frecuentes.
# Consideraciones: Este timeout debe ser consistente con cualquier timeout en
#                  nivel de UI o de API Gateway que pueda estar presente.
# Comparación: Significativamente mayor que el servicio de autenticación (3s),
#              reconociendo que las operaciones de negocio son más complejas
#              y pueden involucrar múltiples servicios o procesamiento de datos.
resilience4j.timelimiter.instances.businessService.timeoutDuration=8s

###############################################
## =============================================================================
## RESILIENCE4J CONFIGURATION
## =============================================================================
## ==== CIRCUIT BREAKER CONFIGURATION ====
## Circuit Breaker for Auth Service
## slidingWindowSize: Tracks the last 10 requests to determine service health
## - Small enough to respond quickly to failures
## - Large enough to avoid false positives from transient issues
## - Appropriate for APIs with moderate traffic volume
#resilience4j.circuitbreaker.instances.authService.slidingWindowSize=10
## failureRateThreshold: Circuit opens when 50% of requests fail
## - Balanced threshold preventing premature opening while protecting against cascading failures
## - For more critical services, consider lowering this threshold to 20-30%
#resilience4j.circuitbreaker.instances.authService.failureRateThreshold=50
## waitDurationInOpenState: Circuit remains open for 10 seconds before attempting recovery
## - Allows sufficient time for the external service to recover
## - Short enough to restore service quickly if the issue is transient
## - Can be increased for services with longer recovery times
#resilience4j.circuitbreaker.instances.authService.waitDurationInOpenState=10000
## permittedNumberOfCallsInHalfOpenState: Allows 3 test requests when transitioning to half-open
## - Provides a reasonable sample size to determine if service has recovered
## - Small enough to minimize impact if service is still down
## - Balance between quick recovery and protection
#resilience4j.circuitbreaker.instances.authService.permittedNumberOfCallsInHalfOpenState=3
## ==== CIRCUIT BREAKER CONFIGURATION ====
#
## ==== CIRCUIT BREAKER CONFIGURATION Product====
## Circuit Breaker for Product Service
## - Same configuration as auth service for consistency
## - In production, these values should be tuned based on each service's characteristics
## - Different services may require different thresholds based on their SLAs
#resilience4j.circuitbreaker.instances.productService.slidingWindowSize=10
#resilience4j.circuitbreaker.instances.productService.failureRateThreshold=50
#resilience4j.circuitbreaker.instances.productService.waitDurationInOpenState=10000
#resilience4j.circuitbreaker.instances.productService.permittedNumberOfCallsInHalfOpenState=3
## ==== CIRCUIT BREAKER CONFIGURATION Product====
## ==== RETRY CONFIGURATION ====
## Retry for Auth Service
## maxAttempts: Retries failed requests up to 3 times (1 initial + 2 retries)
## - Balances resilience against potential load amplification
## - Suitable for transient network issues or minor service disruptions
## - For critical operations, can be increased with caution
#resilience4j.retry.instances.authService.maxAttempts=3
## waitDuration: Initial delay of 1 second between retries
## - Short enough to maintain responsiveness
## - Long enough to allow minor issues to resolve
## - Should be tuned based on observed failure recovery patterns
#resilience4j.retry.instances.authService.waitDuration=1000
## enableExponentialBackoff: Implements exponential backoff to prevent overwhelming the service
## - Prevents the "retry storm" anti-pattern during partial outages
## - Essential for distributed systems to implement self-healing behaviors
## - Helps service recovery by gradually spacing out retry attempts
#resilience4j.retry.instances.authService.enableExponentialBackoff=true
## exponentialBackoffMultiplier: Each retry waits twice as long as the previous one (1s, 2s, 4s)
## - Standard multiplier that provides reasonable spacing between attempts
## - Helps prevent synchronized retry attempts from multiple instances
## - Higher values provide more aggressive backoff but slower recovery
#resilience4j.retry.instances.authService.exponentialBackoffMultiplier=2
## Retry for Product Service
## - Similar configuration to auth service for consistency
## - Services with different characteristics may need different retry policies
## - Write operations (like product creation) might need different retry strategies than read operations
#resilience4j.retry.instances.productService.maxAttempts=3
#resilience4j.retry.instances.productService.waitDuration=1000
#resilience4j.retry.instances.productService.enableExponentialBackoff=true
#resilience4j.retry.instances.productService.exponentialBackoffMultiplier=2
## ==== RESILIENCE PATTERN INTEGRATION NOTES ====
## In our implementation, we combine patterns in the following order:
## Circuit Breaker (outer) ? Retry (inner) ? API Call
## This ordering ensures:
## 1. Circuit breaker prevents retries when circuit is open, avoiding unnecessary load
## 2. Retry attempts are made only when circuit is closed or half-open
## 3. Failure statistics are properly collected for circuit decision making
## ==== ADDITIONAL RECOMMENDATIONS ====
## Consider adding these patterns for enhanced resilience:
## 1. Timeouts: Prevent thread blocking with configurations like:
##    resilience4j.timelimiter.instances.authService.timeoutDuration=5s
##
## 2. Bulkhead: Implement thread isolation with configurations like:
##    resilience4j.bulkhead.instances.authService.maxConcurrentCalls=20
##
## 3. Rate Limiter: Prevent service abuse with configurations like:
##    resilience4j.ratelimiter.instances.authService.limitForPeriod=50
##    resilience4j.ratelimiter.instances.authService.limitRefreshPeriod=1s
## =============================================================================
## EXTERNAL SERVICE CONFIGURATION
## =============================================================================
###################################
## Configure the base URL for the external service
########################################################################################################################
#https://xmlserver-production.up.railway.app
#
app.server.external.resource.base-url=https://xmlserver-production.up.railway.app
#app.server.external.resource.base-url=http://localhost:443
app.server.external.resource.message-id-path=/api/messages/ids
app.server.external.resource.document-path=/api/documents
##############################Authentication##############################
app.server.external.oauth.base-url=${app.server.external.resource.base-url}
app.server.external.oauth.token-path=/oauth2/token
app.server.external.oauth.grant-type=client_credentials
# SpEL expression that creates a map
app.server.external.oauth.headers={'Authorization':'Basic Y3VzdG9tZXIxOmN1c3RvbWVyMQ==','Content-Type':'application/x-www-form-urlencoded','Accept':'application/json'}
##############################Authentication##############################
########################################################################################################################
# Base URLs for external services
api.auth.username=emilys
api.auth.password=emilyspass
api.auth.expiresInMins=30
api.auth.url=https://dummyjson.com/auth/login
api.product.url=https://dummyjson.com/products/add
# Configure the log pattern to include correlation ID
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] [${spring.application.name:}] [%X{correlationId:-}] %-5level %logger{36} - %msg%n
logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] [${spring.application.name:}] [%X{correlationId:-}] %-5level %logger{36} - %msg%n
